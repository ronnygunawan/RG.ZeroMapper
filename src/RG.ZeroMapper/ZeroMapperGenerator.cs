using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RG.ZeroMapper;

[Generator]
public class ZeroMapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all partial classes
        var partialClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsPartialClass(s),
                transform: static (ctx, _) => GetClassDeclaration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(partialClasses.Collect());

        // Generate the source
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsPartialClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl &&
               classDecl.Modifiers.Any(SyntaxKind.PartialKeyword);
    }

    private static ClassDeclarationSyntax? GetClassDeclaration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        return classDeclaration;
    }

    private static void Execute(Compilation compilation, IEnumerable<ClassDeclarationSyntax> classes, SourceProductionContext context)
    {
        foreach (var classDecl in classes)
        {
            var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);

            if (classSymbol is null)
                continue;

            // Get all other classes in the compilation to generate implicit operators
            var allClasses = GetAllClasses(compilation);

            var source = GenerateImplicitOperators(classSymbol, allClasses, compilation);
            if (!string.IsNullOrEmpty(source))
            {
                var fileName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                    .Replace("global::", "")
                    .Replace(":", "_")
                    .Replace("<", "_")
                    .Replace(">", "_");
                context.AddSource($"{fileName}.g.cs", source);
            }
        }
    }

    private static List<INamedTypeSymbol> GetAllClasses(Compilation compilation)
    {
        var classes = new List<INamedTypeSymbol>();
        
        void CollectTypes(INamespaceSymbol namespaceSymbol)
        {
            foreach (var member in namespaceSymbol.GetMembers())
            {
                if (member is INamespaceSymbol childNamespace)
                {
                    CollectTypes(childNamespace);
                }
                else if (member is INamedTypeSymbol typeSymbol && typeSymbol.TypeKind == TypeKind.Class)
                {
                    classes.Add(typeSymbol);
                }
            }
        }

        CollectTypes(compilation.GlobalNamespace);
        return classes;
    }

    private static string GenerateImplicitOperators(INamedTypeSymbol targetClass, List<INamedTypeSymbol> allClasses, Compilation compilation)
    {
        var sb = new StringBuilder();

        // Get namespace
        var namespaceName = targetClass.ContainingNamespace.IsGlobalNamespace
            ? null
            : targetClass.ContainingNamespace.ToDisplayString();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (namespaceName != null)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        var indent = namespaceName != null ? "    " : "";

        sb.AppendLine($"{indent}partial class {targetClass.Name}");
        sb.AppendLine($"{indent}{{");

        // Get target properties and fields
        var targetMembers = GetMappableMembers(targetClass);

        if (targetMembers.Count == 0)
        {
            sb.AppendLine($"{indent}}}");
            if (namespaceName != null)
                sb.AppendLine("}");
            return sb.ToString();
        }

        var generatedOperators = new HashSet<string>();

        // Generate implicit conversion operators from other types
        foreach (var sourceClass in allClasses)
        {
            if (SymbolEqualityComparer.Default.Equals(sourceClass, targetClass))
                continue;

            // Skip non-public classes
            if (sourceClass.DeclaredAccessibility != Accessibility.Public &&
                sourceClass.DeclaredAccessibility != Accessibility.Internal)
                continue;

            // Skip classes from different assemblies (only map within same assembly)
            if (!SymbolEqualityComparer.Default.Equals(sourceClass.ContainingAssembly, targetClass.ContainingAssembly))
                continue;

            var sourceMembers = GetMappableMembers(sourceClass);
            
            // Check if we can map from source to target
            var mappablePairs = GetMappablePairs(sourceMembers, targetMembers);
            
            if (mappablePairs.Count > 0)
            {
                var operatorKey = $"from_{sourceClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}";
                if (!generatedOperators.Contains(operatorKey))
                {
                    generatedOperators.Add(operatorKey);
                    GenerateImplicitOperator(sb, sourceClass, targetClass, mappablePairs, indent + "    ");
                }
            }
        }

        sb.AppendLine($"{indent}}}");

        if (namespaceName != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static List<MemberInfo> GetMappableMembers(INamedTypeSymbol typeSymbol)
    {
        var members = new List<MemberInfo>();

        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is IFieldSymbol field && !field.IsStatic && field.DeclaredAccessibility == Accessibility.Public)
            {
                members.Add(new MemberInfo(field.Name, field.Type, true));
            }
            else if (member is IPropertySymbol property && !property.IsStatic && property.DeclaredAccessibility == Accessibility.Public)
            {
                members.Add(new MemberInfo(property.Name, property.Type, false));
            }
        }

        return members;
    }

    private static List<MemberPair> GetMappablePairs(List<MemberInfo> sourceMembers, List<MemberInfo> targetMembers)
    {
        var pairs = new List<MemberPair>();

        foreach (var target in targetMembers)
        {
            foreach (var source in sourceMembers)
            {
                // Case-insensitive name matching and type compatibility check
                if (string.Equals(source.Name, target.Name, System.StringComparison.OrdinalIgnoreCase) &&
                    SymbolEqualityComparer.Default.Equals(source.Type, target.Type))
                {
                    pairs.Add(new MemberPair(source, target));
                    break;
                }
            }
        }

        return pairs;
    }

    private static void GenerateImplicitOperator(StringBuilder sb, INamedTypeSymbol sourceType, INamedTypeSymbol targetType, List<MemberPair> mappablePairs, string indent)
    {
        var sourceTypeName = sourceType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var targetTypeName = targetType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var sourceFullTypeName = sourceType.ToDisplayString();
        var targetFullTypeName = targetType.ToDisplayString();

        sb.AppendLine($"{indent}public static implicit operator {targetTypeName}({sourceFullTypeName} source)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    var target = new {targetTypeName}();");

        foreach (var pair in mappablePairs)
        {
            var sourceAccess = pair.Source.IsField ? $"source.{pair.Source.Name}" : $"source.{pair.Source.Name}";
            var targetAccess = pair.Target.IsField ? $"target.{pair.Target.Name}" : $"target.{pair.Target.Name}";
            
            sb.AppendLine($"{indent}    {targetAccess} = {sourceAccess};");
        }

        sb.AppendLine($"{indent}    return target;");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private class MemberInfo
    {
        public string Name { get; }
        public ITypeSymbol Type { get; }
        public bool IsField { get; }

        public MemberInfo(string name, ITypeSymbol type, bool isField)
        {
            Name = name;
            Type = type;
            IsField = isField;
        }
    }

    private class MemberPair
    {
        public MemberInfo Source { get; }
        public MemberInfo Target { get; }

        public MemberPair(MemberInfo source, MemberInfo target)
        {
            Source = source;
            Target = target;
        }
    }
}
