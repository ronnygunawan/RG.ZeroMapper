using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RG.ZeroMapper.Structural;

[Generator]
public class StructuralTypingGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Generate support types (Constant, Intersect, Union, OneOf) once per compilation
        context.RegisterPostInitializationOutput(ctx => GenerateSupportTypes(ctx));

        // Find all partial classes that inherit from Intersect, Union, or OneOf
        var structuralClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsStructuralClass(s),
                transform: static (ctx, _) => GetClassInfo(ctx))
            .Where(static m => m != null);

        var compilationAndClasses = context.CompilationProvider.Combine(structuralClasses.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsStructuralClass(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDecl)
            return false;

        if (classDecl.BaseList == null)
            return false;

        return classDecl.BaseList.Types.Any(bt =>
        {
            var typeName = bt.Type.ToString();
            return typeName.StartsWith("Intersect<") ||
                   typeName.StartsWith("Union<") ||
                   typeName.StartsWith("OneOf<");
        });
    }

    private static ClassInfo? GetClassInfo(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var symbol = semanticModel.GetDeclaredSymbol(classDeclaration);

        if (symbol is not INamedTypeSymbol classSymbol || classSymbol.BaseType == null)
            return null;

        var baseType = classSymbol.BaseType;
        var baseTypeName = baseType.Name;

        if (baseTypeName != "Intersect" && baseTypeName != "Union" && baseTypeName != "OneOf")
            return null;

        return new ClassInfo(classSymbol, baseType, baseTypeName);
    }

    private static void Execute(Compilation compilation, IEnumerable<ClassInfo> classes, SourceProductionContext context)
    {
        foreach (var classInfo in classes)
        {
            if (classInfo == null)
                continue;

            var source = classInfo.StructuralType switch
            {
                "Intersect" => GenerateIntersectType(classInfo, compilation),
                "Union" => GenerateUnionType(classInfo, compilation),
                "OneOf" => GenerateOneOfType(classInfo, compilation),
                _ => null
            };

            if (!string.IsNullOrEmpty(source))
            {
                var fileName = classInfo.ClassSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                    .Replace("global::", "")
                    .Replace(":", "_")
                    .Replace("<", "_")
                    .Replace(">", "_");
                context.AddSource($"{fileName}.g.cs", source);
            }
        }
    }

    private static string GenerateIntersectType(ClassInfo classInfo, Compilation compilation)
    {
        var sb = new StringBuilder();
        var namespaceName = classInfo.ClassSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : classInfo.ClassSymbol.ContainingNamespace.ToDisplayString();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (namespaceName != null)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        var indent = namespaceName != null ? "    " : "";

        sb.AppendLine($"{indent}partial class {classInfo.ClassSymbol.Name}");
        sb.AppendLine($"{indent}{{");

        // Get all type arguments from the base type
        var typeArguments = classInfo.BaseType.TypeArguments;
        
        // Find common properties/fields (intersection)
        var commonMembers = GetCommonMembers(typeArguments);

        // Generate properties for common members
        foreach (var member in commonMembers)
        {
            var typeName = member.Type.ToDisplayString();
            sb.AppendLine($"{indent}    public {typeName} {member.Name} {{ get; set; }}");
        }

        sb.AppendLine();

        // Generate implicit conversion operators FROM each type argument TO intersection
        // Intersection: T1 & T2 means you can pass T1 or T2 where Intersect<T1, T2> is expected
        foreach (var typeArg in typeArguments)
        {
            var typeName = typeArg.ToDisplayString();
            sb.AppendLine($"{indent}    public static implicit operator {classInfo.ClassSymbol.Name}({typeName} source)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        var result = new {classInfo.ClassSymbol.Name}();");
            
            // Copy common properties
            foreach (var member in commonMembers)
            {
                sb.AppendLine($"{indent}        result.{member.Name} = source.{member.Name};");
            }
            
            sb.AppendLine($"{indent}        return result;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
        }

        sb.AppendLine($"{indent}}}");

        if (namespaceName != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static string GenerateUnionType(ClassInfo classInfo, Compilation compilation)
    {
        var sb = new StringBuilder();
        var namespaceName = classInfo.ClassSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : classInfo.ClassSymbol.ContainingNamespace.ToDisplayString();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (namespaceName != null)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        var indent = namespaceName != null ? "    " : "";

        sb.AppendLine($"{indent}partial class {classInfo.ClassSymbol.Name}");
        sb.AppendLine($"{indent}{{");

        // Get all type arguments from the base type
        var typeArguments = classInfo.BaseType.TypeArguments;
        
        // Find all unique properties/fields (union)
        var allMembers = GetAllUniqueMembers(typeArguments);

        // Generate properties for all members
        foreach (var member in allMembers)
        {
            var typeName = member.Type.ToDisplayString();
            sb.AppendLine($"{indent}    public {typeName}? {member.Name} {{ get; set; }}");
        }

        sb.AppendLine();

        // Generate implicit conversion operators FROM union TO each type argument
        // Union: T1 | T2 means you can pass Union<T1, T2> where T1 or T2 is expected
        foreach (var typeArg in typeArguments)
        {
            if (IsConstantType(typeArg))
                continue;

            var typeName = typeArg.ToDisplayString();
            var typeMembers = GetMembersFromType(typeArg).ToList();
            
            sb.AppendLine($"{indent}    public static implicit operator {typeName}({classInfo.ClassSymbol.Name} source)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        var result = new {typeName}();");
            
            // Copy properties that exist in the target type
            foreach (var typeMember in typeMembers)
            {
                if (allMembers.Any(m => string.Equals(m.Name, typeMember.Name, System.StringComparison.OrdinalIgnoreCase)))
                {
                    sb.AppendLine($"{indent}        result.{typeMember.Name} = source.{typeMember.Name} ?? default!;");
                }
            }
            
            sb.AppendLine($"{indent}        return result;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
        }

        // Handle constant values
        var constants = GetConstantValues(typeArguments);
        if (constants.Count > 0)
        {
            // Generate implicit conversion operators for constants
            foreach (var constant in constants)
            {
                var constType = constant.Type.ToDisplayString();
                var constValue = constant.Value;
                
                sb.AppendLine($"{indent}    public static implicit operator {classInfo.ClassSymbol.Name}({constType} value)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (!Equals(value, {constValue}))");
                sb.AppendLine($"{indent}            throw new System.ArgumentException($\"Value must be {constValue}\");");
                sb.AppendLine($"{indent}        return new {classInfo.ClassSymbol.Name}();");
                sb.AppendLine($"{indent}    }}");
                
                sb.AppendLine();
                sb.AppendLine($"{indent}    public static implicit operator {constType}({classInfo.ClassSymbol.Name} value)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        return {constValue};");
                sb.AppendLine($"{indent}    }}");
            }
        }

        sb.AppendLine($"{indent}}}");

        if (namespaceName != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static string GenerateOneOfType(ClassInfo classInfo, Compilation compilation)
    {
        var sb = new StringBuilder();
        var namespaceName = classInfo.ClassSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : classInfo.ClassSymbol.ContainingNamespace.ToDisplayString();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (namespaceName != null)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        var indent = namespaceName != null ? "    " : "";

        sb.AppendLine($"{indent}partial class {classInfo.ClassSymbol.Name}");
        sb.AppendLine($"{indent}{{");

        // Get all type arguments from the base type
        var typeArguments = classInfo.BaseType.TypeArguments;

        // Store the value and discriminator
        sb.AppendLine($"{indent}    private object? _value;");
        sb.AppendLine($"{indent}    private int _discriminator = -1;");
        sb.AppendLine();

        // Generate conversion operators for each type
        for (int i = 0; i < typeArguments.Length; i++)
        {
            var typeArg = typeArguments[i];
            var typeName = typeArg.ToDisplayString();
            
            // From type to OneOf (implicit)
            sb.AppendLine($"{indent}    public static implicit operator {classInfo.ClassSymbol.Name}({typeName} value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        return new {classInfo.ClassSymbol.Name} {{ _value = value, _discriminator = {i} }};");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // From OneOf to type (implicit with runtime check)
            sb.AppendLine($"{indent}    public static implicit operator {typeName}({classInfo.ClassSymbol.Name} value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (value._discriminator != {i})");
            sb.AppendLine($"{indent}            throw new System.InvalidCastException($\"Cannot convert to {typeName}. Current type is {{value._discriminator}}\");");
            sb.AppendLine($"{indent}        return ({typeName})value._value!;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
        }

        // Generate As<T>() generic method
        sb.AppendLine($"{indent}    public T? As<T>()");
        sb.AppendLine($"{indent}    {{");
        for (int i = 0; i < typeArguments.Length; i++)
        {
            var typeArg = typeArguments[i];
            var typeName = typeArg.ToDisplayString();
            
            if (i == 0)
            {
                sb.AppendLine($"{indent}        if (typeof(T) == typeof({typeName}))");
            }
            else
            {
                sb.AppendLine($"{indent}        else if (typeof(T) == typeof({typeName}))");
            }
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            return _discriminator == {i} ? (T)(object)({typeName})_value! : default(T);");
            sb.AppendLine($"{indent}        }}");
        }
        sb.AppendLine($"{indent}        return default(T);");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();

        // Generate TryCast<T>() generic method
        sb.AppendLine($"{indent}    public bool TryCast<T>([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T? value)");
        sb.AppendLine($"{indent}    {{");
        for (int i = 0; i < typeArguments.Length; i++)
        {
            var typeArg = typeArguments[i];
            var typeName = typeArg.ToDisplayString();
            
            if (i == 0)
            {
                sb.AppendLine($"{indent}        if (typeof(T) == typeof({typeName}))");
            }
            else
            {
                sb.AppendLine($"{indent}        else if (typeof(T) == typeof({typeName}))");
            }
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            if (_discriminator == {i})");
            sb.AppendLine($"{indent}            {{");
            sb.AppendLine($"{indent}                value = (T)(object)({typeName})_value!;");
            sb.AppendLine($"{indent}                return true;");
            sb.AppendLine($"{indent}            }}");
            sb.AppendLine($"{indent}        }}");
        }
        sb.AppendLine($"{indent}        value = default(T);");
        sb.AppendLine($"{indent}        return false;");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();

        // Generate Switch method (void return)
        sb.Append($"{indent}    public void Switch(");
        for (int i = 0; i < typeArguments.Length; i++)
        {
            var typeArg = typeArguments[i];
            var typeName = typeArg.ToDisplayString();
            if (i > 0) sb.Append(", ");
            sb.Append($"System.Action<{typeName}> case{i + 1}");
        }
        sb.AppendLine(")");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        switch (_discriminator)");
        sb.AppendLine($"{indent}        {{");
        for (int i = 0; i < typeArguments.Length; i++)
        {
            var typeArg = typeArguments[i];
            var typeName = typeArg.ToDisplayString();
            sb.AppendLine($"{indent}            case {i}:");
            sb.AppendLine($"{indent}                case{i + 1}(({typeName})_value!);");
            sb.AppendLine($"{indent}                break;");
        }
        sb.AppendLine($"{indent}        }}");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();

        // Generate Switch<R> method (with return value)
        sb.Append($"{indent}    public R Switch<R>(");
        for (int i = 0; i < typeArguments.Length; i++)
        {
            var typeArg = typeArguments[i];
            var typeName = typeArg.ToDisplayString();
            if (i > 0) sb.Append(", ");
            sb.Append($"System.Func<{typeName}, R> case{i + 1}");
        }
        sb.AppendLine(")");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        return _discriminator switch");
        sb.AppendLine($"{indent}        {{");
        for (int i = 0; i < typeArguments.Length; i++)
        {
            var typeArg = typeArguments[i];
            var typeName = typeArg.ToDisplayString();
            sb.AppendLine($"{indent}            {i} => case{i + 1}(({typeName})_value!),");
        }
        sb.AppendLine($"{indent}            _ => throw new System.InvalidOperationException(\"OneOf is in an invalid state\")");
        sb.AppendLine($"{indent}        }};");
        sb.AppendLine($"{indent}    }}");

        sb.AppendLine($"{indent}}}");

        if (namespaceName != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static List<MemberData> GetCommonMembers(IEnumerable<ITypeSymbol> types)
    {
        var typesList = types.ToList();
        if (typesList.Count == 0)
            return new List<MemberData>();

        // Start with members from first type
        var commonMembers = GetMembersFromType(typesList[0]).ToList();

        // Intersect with members from other types
        for (int i = 1; i < typesList.Count; i++)
        {
            var currentMembers = GetMembersFromType(typesList[i]);
            commonMembers = commonMembers.Where(cm =>
                currentMembers.Any(m =>
                    string.Equals(m.Name, cm.Name, System.StringComparison.OrdinalIgnoreCase) &&
                    SymbolEqualityComparer.Default.Equals(m.Type, cm.Type)))
                .ToList();
        }

        return commonMembers;
    }

    private static List<MemberData> GetAllUniqueMembers(IEnumerable<ITypeSymbol> types)
    {
        var allMembers = new Dictionary<string, MemberData>(System.StringComparer.OrdinalIgnoreCase);

        foreach (var type in types)
        {
            // Skip Constant types
            if (IsConstantType(type))
                continue;

            foreach (var member in GetMembersFromType(type))
            {
                if (!allMembers.ContainsKey(member.Name))
                {
                    allMembers[member.Name] = member;
                }
            }
        }

        return allMembers.Values.ToList();
    }

    private static List<ConstantData> GetConstantValues(IEnumerable<ITypeSymbol> types)
    {
        var constants = new List<ConstantData>();

        foreach (var type in types)
        {
            if (IsConstantType(type))
            {
                // Extract the constant value from Constant(value) record
                var baseType = type.BaseType;
                if (baseType != null && baseType.Name == "Constant")
                {
                    // Try to extract value - this is simplified
                    // In a real implementation, we'd need to analyze the record constructor
                    constants.Add(new ConstantData(type, "1")); // Default to 1 as per README
                }
            }
        }

        return constants;
    }

    private static bool IsConstantType(ITypeSymbol type)
    {
        var baseType = type.BaseType;
        while (baseType != null)
        {
            if (baseType.Name == "Constant")
                return true;
            baseType = baseType.BaseType;
        }
        return false;
    }

    private static IEnumerable<MemberData> GetMembersFromType(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            yield break;

        foreach (var member in namedType.GetMembers())
        {
            if (member is IFieldSymbol field && !field.IsStatic && field.DeclaredAccessibility == Accessibility.Public)
            {
                yield return new MemberData(field.Name, field.Type);
            }
            else if (member is IPropertySymbol property && !property.IsStatic && property.DeclaredAccessibility == Accessibility.Public)
            {
                yield return new MemberData(property.Name, property.Type);
            }
        }
    }

    private static string GetTypeArgumentName(int index)
    {
        return index switch
        {
            1 => "T1",
            2 => "T2",
            3 => "T3",
            4 => "T4",
            5 => "T5",
            6 => "T6",
            7 => "T7",
            8 => "T8",
            9 => "T9",
            10 => "T10",
            11 => "T11",
            12 => "T12",
            13 => "T13",
            14 => "T14",
            15 => "T15",
            16 => "T16",
            _ => $"T{index}"
        };
    }

    private class ClassInfo
    {
        public INamedTypeSymbol ClassSymbol { get; }
        public INamedTypeSymbol BaseType { get; }
        public string StructuralType { get; }

        public ClassInfo(INamedTypeSymbol classSymbol, INamedTypeSymbol baseType, string structuralType)
        {
            ClassSymbol = classSymbol;
            BaseType = baseType;
            StructuralType = structuralType;
        }
    }

    private class MemberData
    {
        public string Name { get; }
        public ITypeSymbol Type { get; }

        public MemberData(string name, ITypeSymbol type)
        {
            Name = name;
            Type = type;
        }
    }

    private class ConstantData
    {
        public ITypeSymbol Type { get; }
        public string Value { get; }

        public ConstantData(ITypeSymbol type, string value)
        {
            Type = type;
            Value = value;
        }
    }

    private static void GenerateSupportTypes(IncrementalGeneratorPostInitializationContext context)
    {
        // Base types (Constant, Intersect, Union, OneOf) are now provided by the
        // RG.ZeroMapper.Structural.Abstractions package to avoid type conflicts
        // when multiple projects reference RG.ZeroMapper.Structural.
        // This method is kept for backwards compatibility but does not generate anything.
    }
}
